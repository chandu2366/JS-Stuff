<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <script>


        function print(str){
            console.log (str,  ':', eval(str) );
        }

        // Closure --> Function object and its scope when the function was defined
        // A closure is a function having access to the parent scope, even after the parent function has closed.

        // A closure is an inner function that has access to the outer (enclosing) function's variablesâ€”scope chain.
        // The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets),
        // it has access to the outer function's variables, and it has access to the global variables.

        function createClosure() {
            var x = 10;
            return function getX() {
                return x++;
            }
        }

        // console.log(x);

        var fx = createClosure(); // created a closure
        print('fx()');
        print('fx()');

        var fy = createClosure(); // created a closure
        print('fy()');
        print('fy()');

        var add = (function () {
            var counter = 0;
            return function () {return counter += 1;}
        })();

        add(); //first time, the counter = 1, second call counter is 2 etc

        // The variable add is assigned the return value of a self-invoking function.
        // The self-invoking function only runs once. It sets the counter to zero (0), and returns a function expression.
        // This way add becomes a function. The "wonderful" part is that it can access the counter in the parent scope.
        // This is called a JavaScript closure. It makes it possible for a function to have "private" variables.
        // The counter is protected by the scope of the anonymous function, and can only be changed using the add function.

    </script>

</head>
<body>

</body>
</html>